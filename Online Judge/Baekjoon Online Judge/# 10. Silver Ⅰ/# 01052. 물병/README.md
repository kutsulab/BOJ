# \[BOJ01052] 물병

- 난이도 : Silve1
- 물병을 지정 갯수 이하로 분배하기
- 문제 : <a href="https://www.acmicpc.net/problem/1052" target="_blank">링크</a>
- 풀이 소스코드 :  <a href="src/Main.java" target="_blank">gitHub</a>

---  

## Main.java : 백준 제출 답안
```
int N = Integer.parseInt(st.nextToken()); // 전체 물병의 갯수
int K = Integer.parseInt(st.nextToken()); // 재분배 결과, 최대 병의 갯수

int buyBottle = 0; // 사야하는 병의 갯수
```
- 물병은 같은 용량 단위로만 묶을 수 있고 같은 용량의 경우 묶여지므로 결국 2, 2^2, 2^3, ... 단위로 하나씩 묶여진다.
- 이는 N을 이진법으로 표현한 것과 구조적으로 동일해진다.
- 전체 물병의 갯수를 N, 재분배 최대 갯수를 K라 하고, 구입해야하는 병의 갯수를 buyBottle이라고 하자.

```
while (true) {
    int count = 0;
    int number = N;
    while (number>0) {
        if (number%2 == 1) count ++; // 병의 재분배는 물병의 갯수를 이진수로 만들었을 때 1의 갯수와 구조적 동일하다.
        number = number >> 1; // 오른쪽으로 비트를 민다(자릿수를 내린다) : 2로 나누는 행위와 구조적 동일
    }
    if (count <=K) break; // (탈출 조건) 1의 갯수가 K 이하이면 조건에 부합하므로 반복을 탈출
    buyBottle ++; // 조건에 부합하지 않으므로 사야하는 병의 갯수가 증가한다.
    N ++; // 병을 구입하여 전체 물병의 갯수가 변화함. 다시 처음으로 돌아가 계산을 반복한다.
}
System.out.print(buyBottle);
```
- 무한 반복 (탈출조건 : count <=K)
- count : 1의 갯수 (분배 결과 남게 된 병의 갯수)
- number : 병을 분할하기 위해 사용하는 변수. N을 읽어와 2로 나눠가며 처리하기위해 사용한다.
- 2진법 변환과 구조적 동일한 과정으로 분배된 병의 상태를 확인.
- 분배된 병의 갯수, 즉 최종적으로 남게된 1의 갯수를 읽어서 K이하인지 확인한다. K 이하일 경우, 조건에 부합하는 상황이므로 무한 반복을 탈출한다.
- 조건에 부합하지 않으면 buyBottle을 증가시키고, N 역시 증가시킨뒤 다시 반복한다.
- 최종적으로 buyBottle을 출력한다.

---

## Review
- 구글에서 문제 설명을 여러번 찾아보고, 읽어보더라도 그 뜻을 이해하는데 오랜 시간이 걸렸다.
- 어떤 분은 비트 연산자까지 쓰시면서 숫자값을 제어하시고 속도를 향상시키더라. 나는 그렇게까지 low 레벨로 다루는 역량은 아직 부족해서 너무 먼 세계 같았다.
- 내 시간 돌려줘요. 오늘 이거 풀다 시간 다 갔어.

---